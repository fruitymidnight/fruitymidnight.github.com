
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="author" content="Shin">
  <meta name="description" content="Shin's blog">

  
    <title>Apple セキュアコーディングガイド（日本語訳） - Shin</title>
  


  
  <meta name="description" content="Apple セキュアコーディングガイド（日本語訳） セキュリティ開発のチェックリスト <!--
This appendix presents a set of security audit checklists that you can use to help reduce the &hellip;">
  



  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fruitymidnight.github.io/apple-secure-coding-guideline">
  <link href="/favicon.ico" rel="icon">
  <script type="text/javascript" src="http://use.typekit.com/zcp2xbp.js"></script>
  <script type="text/javascript">try{Typekit.load();}catch(e){}</script>  
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Shin's blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>


<body   >

  <div class="container">

    <div class="four columns">
        <nav role="navigation"><ul class="title">
  <li><a href="/">fruitymidnight.com</a></li>
</ul>
  
<ul class="main-navigation">

  <li class="other"><a href="/">Blog</a></li>

</ul>


<ul class="subscription" data-subscription="rss">
  <li class="other"><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:fruitymidnight.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  



</nav>
        <aside class="sidebar">
          
            <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/03/26/apple-secure-coding-guideline/">apple-secure-coding-guideline</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/17/android-programming-memo-20130217/">SpannableStringBuilder SPAN_EXCLUSIVE_EXCLUSIVE spans cannot have a zero length</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/19/localsocket/">LocalSocket</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/14/first-post/">Github Pages でブログ</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/06/01/this-is-a-test/">This is post</a>
      </li>
    
  </ul>
</section>

          

          <section>
            <h1>Link</h1>
              <ul>
                <li><a target="_blank" href="https://github.com/fruitymidnight" target="_blank">GitHub</a></li>
                <li><a target="_blank" href="https://bitbucket.org/fruitymidnight" target="_blank">Bitbucket</a></li>
              </ul>
          </section>

        </aside>    
    </div>

    <div id="main" class="twelve columns">
      <div id="content">
        <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">Apple セキュアコーディングガイド（日本語訳）</h1>
  </header>
  
  <p><link href="https://raw.github.com/simonlc/Markdown-CSS/master/markdown.css" rel="stylesheet"></link></p>

<h1>セキュリティ開発のチェックリスト <!-- Security Development Checklists --></h1>

<!--
This appendix presents a set of security audit checklists that you can use to help reduce the security vulnerabilities of your software. These checklists are designed to be used during software development. If you read this section all the way through before you start coding, you may avoid many security pitfalls that are difficult to correct in a completed program.
-->


<p>この付録はあなたのソフトウェアのセキュリティ脆弱性を減らすのに役立つセキュリティ検査チェックリストのセットを提供します。
これらのチェックリストはソフトウェア開発期間中に使用されるものとして設計されています。
もしあなたがコーディングを開始する前にこの章を最初から最後まで読めば、
完成したプログラムで修正するのが困難な多くのセキュリティ上の罠を回避することができるでしょう。</p>

<!--
Note that these checklists are not exhaustive; you might not have any of the potential vulnerabilities discussed here and still have insecure code. Also, as the author of the code, you are probably too close to the code to be fully objective, and thus may overlook certain flaws. For this reason, it’s very important that you have your code reviewed for security problems by an independent reviewer. A security expert would be best, but any competent programmer, if aware of what to look for, might find problems that you may have missed. In addition, whenever the code is updated or changed in any way, including to fix bugs, it should be checked again for security problems.
-->


<p>これらのチェックリストは網羅的ではないことに注意してください。
ここで説明した潜在的な脆弱性がいくつかあるかもしれないし、まだ安全ではないコードがあるかもしれない。
また、コード作成者として、あなたはおそらく客観的になるにはコードに近すぎます。その故、ある欠陥を見落とすかもしれない。
このため、別のレビュワーによってセキュリティのためにあなたのコードをレビューされることは非常に重要です。
セキュリティのエクスパートがベストでしょうが、何を探すかわかっている有能なプログラマーならばあなたがミスしただろう問題を発見できるでしょう。
さらに付け加えると、バグ修正も含めて、コードが更新もしくは何らかの方法で変更されたときはいつでも、セキュリティ問題のために再チェックすべきです。</p>

<!--
Important: All code should have a security audit before being released.
-->


<p><strong>重要：リリース前に全てのコードはセキュリティチェックを受けるべきです</strong></p>

<h1>特権の使用 <!-- Use of Privilege --></h1>

<!--
This checklist is intended to determine whether your code ever runs with elevated privileges, and if it does, how best to do so safely. Note that it’s best to avoid running with elevated privileges if possible; see “Avoiding Elevated Privileges.”
-->


<p>このチェックリストは、あなたのコードを権限昇格させて実行させないこと、また、もし権限昇格させて実行する場合でも、安全に行うベストの方法を決めることを意図しています。
出来る限り権限昇格を伴う実行を避けることがベストであることに注意してください。&#8221;Avoiding Elevated Privileges.&#8221; を参照してください。</p>

<!-- Reduce privileges whenever possible. -->


<!-- If you are using privilege separation with sandboxing or other privilege-limiting techniques, you should be careful to ensure that your helper tools are designed to limit the damage that they can cause if the main application gets compromised, and vice-versa. Read “Designing Secure Helpers And Daemons” to learn how. -->


<!-- Also, for daemons that start with elevated privileges and then drop privileges, you should always use a locally unique user ID for your program. See “Run Daemons As Unique Users” to learn more. -->


<!-- Use elevated privileges sparingly, and only in privileged helpers.-->


<!-- In most cases, a program can get by without elevated privileges, but sometimes a program needs elevated privileges to perform a limited number of operations, such as writing files to a privileged directory or opening a privileged port. -->


<!-- If an attacker finds a vulnerability that allows execution of arbitrary code, the attacker’s code runs with the same privilege as the running code, and can take complete control of the computer if that code has root privileges. Because of this risk, you should avoid elevating privileges if at all possible. -->


<!-- If you must run code with elevated privileges, here are some rules: -->


<ol>
<li><p>可能なときはいつでも権限を縮小すること</p>

<p> もし あなたがサンドボックスによる権限分離や他の権限を制限するテクニックを利用するならば、あなたのヘルパーツールが、メインアプリケーションに障害が発生した場合、それらが引き起こすダメージを制限するように設計されているか保証するように注意するべきです。またその逆の場合も同様です。
使い方を習得するために &#8220;Designing Secure Helpers And Daemons&#8221; を読んでください。</p>

<p>  また、権限昇格されてスタートし、権限を落とされるデーモンについては、あなたは常にローカルでユニークなユーザIDを使用すべきです。より多くを知るには &#8220;Run Daemons As Unique Users&#8221; を見てください。</p></li>
<li><p>控えめな、そして権限ヘルパーでのみ権限昇格の使用</p>

<p> ほとんどの場合、プログラムは権限昇格無しで利用することができる。しかし、あるプログラムはある限られた数の操作、特権的なディレクトリへのファイル書き込みや特権的なポートを開くといった、を行うために権限昇格を時々必要とする、</p>

<p> もしアタッカーが任意のコードの実行を許す脆弱性を発見した場合、アタッカーのコードは実行中のコードと同じ権限で実行される。そしてもしそのコードがルート権限を持っていたとしたらそのコンピュータの全てのコントロールをとることができる。このリスクにより、出来る限り権限昇格をさけるべきである。</p>

<p> もしあなたが権限昇格を伴うコードを実行しなければならない場合、下記がルールである</p></li>
</ol>


<p>Never run your main process as a different user. Instead, create a separate helper tool that runs with elevated privileges.
Your helper tool should do as little as possible.
Your helper tool should restrict what you can ask it to do as much as possible.
Your helper tool should either drop the elevated privileges or stop executing as soon as possible.
Important: If all or most of your code runs with root or other elevated privileges, or if you have complex code that performs multiple operations with elevated privileges, then your program could have a serious security vulnerability. You should seek help in performing a security audit of your code to reduce your risk.
See “Elevating Privileges Safely” and “Designing Secure Helpers And Daemons” for more information.
Use launchd when possible.
If you are writing a daemon or other process that runs with elevated privileges, you should always use launchd to start it. (To learn why other mechanisms are not recommended, read “Limitations And Risks Of Other Mechanisms.”)</p>

<p>For more information on launchd, see the manual pages for launchd, launchctl, and launchd.plist, and Daemons and Services Programming Guide. For more information about startup items, see Daemons and Services Programming Guide. For more information on ipfw, see the ipfw manual page.</p>

<p>Avoid using sudo programmatically.
If authorized to do so in the sudoers file, a user can use sudo to execute a command as root. The sudo command is intended for occasional administrative use by a user sitting at the computer and typing into the Terminal application. Its use in scripts or called from code is not secure.</p>

<p>After executing the sudo command—which requires authenticating by entering a password—there is a five-minute period (by default) during which the sudo command can be executed without further authentication. It’s possible for another process to take advantage of this situation to execute a command as root.</p>

<p>Further, there is no encryption or protection of the command being executed. Because sudo is used to execute privileged commands, the command arguments often include user names, passwords, and other information that should be kept secret. A command executed in this way by a script or other code can expose confidential data to possible interception and compromise.</p>

<p>Minimize the amount of code that must be run with elevated privileges.
Ask yourself approximately how many lines of code need to run with elevated privileges. If this answer is either “all” or is a difficult number to compute, then it will be very difficult to perform a security review of your software.</p>

<p>If you can’t determine how to factor your application to separate out the code that needs privileges, you are strongly encouraged to seek assistance with your project immediately. If you are an ADC member, you are encouraged to ask for help from Apple engineers with factoring your code and performing a security audit. If you are not an ADC member, see the ADC membership page at http://developer.apple.com/programs/.</p>

<p>Never run a GUI application with elevated privileges.
You should never run a GUI application with elevated privileges. Any GUI application links in many libraries over which you have no control and which, due to their size and complexity, are very likely to contain security vulnerabilities. In this case, your application runs in an environment set by the GUI, not by your code. Your code and your user’s data can then be compromised by the exploitation of any vulnerabilities in the libraries or environment of the graphical interface.</p>

<h1>データ、設定、テンポラリファイル  <!-- Data, Configuration, and Temporary Files --></h1>

<!-- Some security vulnerabilities are related to reading or writing files. This checklist is intended to help you find any such vulnerabilities in your code. -->


<p>いくつかのセキュリティ脆弱性はファイルの読み書きに関係している。このチェックリストはあなたのコードのそのような脆弱性を発見する一助となることを意図している。</p>

<!-- Be careful when working with files in untrusted locations. -->


<!-- If you write to any directory owned by the user, then there is a possibility that the user will modify or corrupt your files. -->




<!-- Similarly, if you write temporary files to a publicly writable place (for example, /tmp, /var/tmp, /Library/Caches or another specific place with this characteristic), an attacker may be able to modify your files before the next time you read them. -->




<!-- If your code reads and writes files (and in particular if it uses files for interprocess communication), you should put those files in a safe directory to which only you have write access. -->




<!-- For more information about vulnerabilities associated with writing files, and how to minimize the risks, see “Time of Check Versus Time of Use.” -->




<!-- Avoid untrusted configuration files, preference files, or environment variables. -->


<!-- In many cases, the user can control environment variables, configuration files, and preferences. If you are executing a program for the user with elevated privileges, you are giving the user the opportunity to perform operations that they cannot ordinarily do. Therefore, you should ensure that the behavior of your privileged code does not depend on these things. -->




<!-- This means: -->


<!-- Validate all input, whether directly from the user or through environment variables, configuration files, preferences files, or other files. -->


<!-- In the case of environment variables, the effect might not be immediate or obvious; however the user might be able to modify the behavior of your program or of other programs or system calls. -->


<!-- Make sure that file paths do not contain wildcard characters, such as ../ or ~, which an attacker can use to switch the current directory to one under the attacker’s control. -->


<!-- Explicitly set the privileges, environment variables, and resources available to the running process, rather than assuming that the process has inherited the correct environment. -->




<!-- Load kernel extensions carefully (or not at all). -->


<!-- A kernel extension is the ultimate privileged code—it has access to levels of the operating system that cannot be touched by ordinary code, even running as root. You must be extremely careful why, how, and when you load a kernel extension to guard against being fooled into loading the wrong one. It’s possible to load a root kit if you’re not sufficiently careful. (A root kit is malicious code that, by running in the kernel, can not only take over control of the system but can cover up all evidence of its own existence.) -->




<!-- To make sure that an attacker hasn’t somehow substituted his or her own kernel extension for yours, you should always store kernel extensions in secure locations. You may, if desired, use code signing or hashes to further verify their authenticity, but this does not remove the need to protect the extension with appropriate permissions. (Time-of-check vs. time-of-use attacks are still possible.) Note that in recent versions of OS X, this is partially mitigated by the KEXT loading system, which refuses to load any kext binary whose owner is not root or whose group is not wheel. -->




<!-- In general, you should avoid writing kernel extensions (see “Keep Out” in Kernel Programming Guide). However, if you must use a kernel extension, use the facilities built into OS X to load your extension and be sure to load the extension from a separate privileged process. -->




<!-- See “Elevating Privileges Safely” to learn more about the safe use of root access. See Kernel Programming Guide for more information on writing and loading kernel extensions. For help on writing device drivers, see I/O Kit Fundamentals. -->


<ol>
<li><p>信頼できない場所にあるファイルを操作するときは注意してください。</p>

<p> もしあなたがあるユーザ所有のディレクトリに書き込む場合、そのユーザがファイルを変更したり、破損する可能性がある。</p>

<p> 同様に、あなたが一時ファイルをパブリックな書き込み可能な場所（例えば、/tmp、/var/tmp、/Library/Caches などの特別な場所）に書く場合、アタッカーはあなたが次に読み込む前にあなたのファイルを変更することが可能である。</p>

<p> もしあなたのコードがファイルを読み書きする場合（特にプロセス内のやり取りのためにファイルを使う場合）、あなたはそのファイルをあなたのみが書き込み権限をもつような安全なディレクトリに置くべきである。</p>

<p> ファイル書き込みに関連する脆弱性やリスクを最小限に抑える方法についての情報は、&#8221;Time of Check Versus Time of Use&#8221; を参照してください。</p></li>
<li><p>信頼できない設定ファイル、プリファレンスファイル、環境変数を避けなさい。</p>

<p> 多くの場合、ユーザは環境変数や設定ファイルやプリファレンスをコントロールできる。
 もしあなたがユーザのために権限昇格を伴ってプログラムを実行する場合、あならはそのユーザに通常では不可能な作業を可能にする機械を与えることになる。
 そのため、あなたの特権のあるコードの振る舞いがそれらに依存しないように安全を確保しなければならない。</p>

<p> これらが意味することを下記に示す：</p>

<ul>
<li><p>ユーザから直接もしくは環境変数や設定ファイル、プリファレンスファイルやその他のファイルだろうと全ての入力を検証すること。</p></li>
<li><p>環境変数のケースでは、その影響は直接的でも明らかでもないかもしれない。
しかしながらユーザがあなたのプログラムや他のプログラムやシステムコールの振る舞いを変更することが可能であるかもしれない。</p></li>
<li><p>ファイルパスが ../ や ~ といったワイルドカード文字を含まないことを確認してください。
それらはアタッカーがカレントディレクトリをアタッカーのコントロール下に切り替えるために使用することができる。</p></li>
<li><p>プロセスが正しい環境を継承していることを前提にするのではなく、権限や環境変数や実行中のプロセスが利用できるリソースを明示的に設定してください</p></li>
</ul>
</li>
<li><p>注意深くカーネルエクステンションをロードしてください（もしくは全くしないでください）</p>

<p> カーネルエクステンションは究極的に特権的コードです。それは root として実行されすらいても通常のコードでは触れることができないOSレベルのアクセスを行います。
 間違ったものをロードするように騙されることを防ぐためにあなたはなぜ、どのように、いつカーネルエクステンションをロードするか細心の注意を払わなければならない。
 十分に注意を払わない場合ルートキットをロードすることが可能になります
 （ルートキットはカーネルで実行することで、システムの制御ののっとりだけでなく、その存在を全ての証拠を隠蔽することができる悪意のあるコードです）。</p>

<p> アタッカーがなんらかの方法であなたのカーネルエクステンションをアタッカーのものに置換していないことを確実にするために、あなたは安全な場所にカーネルエクステンションを格納する必要がある。
 更なる信頼性を確認するために、必要に応じて、コード書名やハッシュを利用するかもしれません。
 しかし、それは適切な権限を用いて拡張機能を保護する必要性をなくすることではない（time-of-check と time-of-use アタックはまだ可能です）。
 最近の OS X のバージョンでは、 KEXT ローディングシステムによって部分的に緩和されている。それは所有者が root ではないかグループが wheel ではない kext バイナリをロードすることを拒否します。</p>

<p> 一般的に、あなたはカーネルエクステンションを書くのを避けるべきです（カーネルプログラミングガイドの中の &#8220;Keep Out&#8221; を参照）。
 しかし、もしあなたがカーネルエクステンションを使用しなければならないのなら、
 あなたのエクステンションをロードや、特権のあるプロセスから確実に分離してロードするためにOSXに内蔵されている機能を使用してください。</p>

<p> ルートアクセスの安全な使用について更に学ぶ場合は &#8220;Elevating Privileges Safely&#8221; を参照してください。
 カーネルエクステンションを書いたり、ロードする場合の更なる情報についてカーネルプログラミングガイドを参照してください。
 デバイスドライバーを書くときのヘルプについては、I/O Kit Fundamentals を参照してください。</p></li>
</ol>


<h1>ネットワークポートの使用 <!-- Network Port Use --></h1>

<!-- This checklist is intended to help you find vulnerabilities related to sending and receiving information over a network. If your project does not contain any tool or application that sends or receives information over a network, skip to “Audit Logs” (for servers) or “Integer and Buffer Overflows” for all other products. -->


<p>このチェックリストはネットワークを介して情報の送信または受信するときに関連する脆弱性を発見する一助となることを意図している。
もしあなたのプロジェクトがネットワークを介して情報の送信または受信をするツールやアプリケーションを含まれていない場合、&#8221;Audit Logs&#8221;（サーバの場合）または&#8221;Interger and Buffer Overflows&#8221;へとスキップしてください。</p>

<!-- Use assigned port numbers. -->


<!-- Port numbers 0 through 1023 are reserved for use by certain services specified by the Internet Assigned Numbers Authority (IANA; see http://www.iana.org/). On many systems including OS X, only processes running as root can bind to these ports. It is not safe, however, to assume that any communications coming over these privileged ports can be trusted. It’s possible that an attacker has obtained root access and used it to bind to a privileged port. Furthermore, on some systems, root access is not needed to bind to these ports. -->




<!-- You should also be aware that if you use the SO_REUSEADDR socket option with UDP, it is possible for a local attacker to hijack your port. -->




<!-- Therefore, you should always use port numbers assigned by the IANA, you should always check return codes to make sure you have connected successfully, and you should check that you are connected to the correct port. Also, as always, never trust input data, even if it’s coming over a privileged port. Whether data is being read from a file, entered by a user, or received over a network, you must validate all input. -->




<!-- See “Validating Input And Interprocess Communication” for more information about validating input. -->




<!-- Choose an appropriate transport protocol. -->


<!-- Lower-level protocols, such as UDP, provide higher performance for some types of traffic, but are easier to spoof than higher-level protocols, such as TCP. -->




<!-- Note that if you’re using TCP, you still need to worry about authenticating both ends of the connection, but there are encryption layers you can add to increase security. -->




<!-- Use existing authentication services when authentication is needed. -->


<!-- If you’re providing a free and nonconfidential service, and do not process user input, then authentication is not necessary. On the other hand, if any secret information is being exchanged, the user is allowed to enter data that your program processes, or there is any reason to restrict user access, then you should authenticate every user. -->




<!-- OS X provides a variety of secure network APIs and authorization services, all of which perform authentication. You should always use these services rather than creating your own authentication mechanism. For one thing, authentication is very difficult to do correctly, and dangerous to get wrong. If an attacker breaks your authentication scheme, you could compromise secrets or give the attacker an entry to your system. -->




<!-- The only approved authorization mechanism for networked applications is Kerberos; see “Client-Server Authentication.” For more information on secure networking, see Secure Transport Reference and CFNetwork Programming Guide. -->




<!-- Verify access programmatically. -->


<!-- UI limitations do not protect your service from attack. If your service provides functionality that should only be accessible to certain users, that service must perform appropriate checks to determine whether the current user is authorized to access that functionality. -->




<!-- If you do not do this, then someone sufficiently familiar with your service can potentially perform unauthorized operations by modifying URLs, sending malicious Apple events, and so on. -->




<!-- Fail gracefully. -->


<!-- If a server is unavailable, either because of some problem with the network or because the server is under a denial of service attack, your client application should limit the frequency and number of retries and should give the user the opportunity to cancel the operation. -->


<!-- Poorly-designed clients that retry connections too frequently and too insistently, or that hang while waiting for a connection, can inadvertently contribute to—or cause their own—denial of service. -->




<!-- Design your service to handle high connection volume. -->


<!-- Your daemon should be capable of surviving a denial of service attack without crashing or losing data. In addition, you should limit the total amount of processor time, memory, and disk space each daemon can use, so that a denial of service attack on any given daemon does not result in denial of service to every process on the system. -->




<!-- You can use the ipfwfirewall program to control packets and traffic flow for internet daemons. For more information on ipfw, see the ipfw(8) manual page. See Wheeler, Secure Programming for Linux and Unix HOWTO, available at http://www.dwheeler.com/secure-programs/, for more advice on dealing with denial of service attacks. -->




<!-- Design hash functions carefully. -->


<!-- Hash tables are often used to improve search performance. However, when there are hash collisions (where two items in the list have the same hash result), a slower (often linear) search must be used to resolve the conflict. If it is possible for a user to deliberately generate different requests that have the same hash result, by making many such requests an attacker can mount a denial of service attack. -->




<!-- It is possible to design hash tables that use complex data structures such as trees in the collision case. Doing so can significantly reduce the damage caused by these attacks. -->


<ol>
<li><p>割り当てられたポート番号の使用。</p>

<p> Internet Assigned Numbers Authority（IANA、http://www.iana.org/ 参照）によって規定されたあるサービスが使用するものとして０から１０２３のポート番号は予約されている。
 OS Xを含む多くのシステム上では、ルートとして実行されているプロセスのみがそれらのポートをにバインドできる。
 しかしながら、それらの特権ポートを介して着信する通信を信頼できるものだと仮定するのは安全ではない。
 アタッカーがルート権限を取得し、特権ポートをバインドするために使用している可能性がある。
 さらに、いくつかのシステム上では、それらのポートにバインドするためにルート権限は必要ではない。</p>

<p> UDPのSO_REUSEADDRソケットオプションを使用するならば、ローカルアタッカーにとってあなたのポートをハイジャックすることはできる、ということについて気をつけなければならない。</p>

<p> それ故に、あなたはいつもIANAから割り当てられたポート番号を利用する必要があります。
 また、あなたはいつも正常に接続したことを確認するためにリターンコードをチェックしなければならない。
 また、正常なポートに接続されているかチェックする必要があります。
 同様に、常に、特権ポートの場合であっても、入力データを信頼することは決してしてはならない。
 ファイル読み込みであっても、ユーザからの入力であっても、ネットワークから受信したデータであっても、あなたは全ての入力を検証しなければならない。</p>

<p> 入力の検証についてより情報を得るためには &#8220;Validating Input And Interprocess Communication&#8221; を参照してください。</p></li>
<li><p>適切なトランスポートプロトコルを選択してください。</p>

<p> UDPといった低レベルのプロトコルはあるタイプのトラフィックに対して高いパフォーマンスを提供する。しかしTCPといった高レベルのプロトコルに比べてspoofが容易である。</p>

<p> もしTCPを使用するのならば、接続の両端を認証することについて注意を払う必要があることが、セキュリティを高めるために暗号レイヤーを追加することができることに注意してください。</p></li>
<li><p>認証が必要な場合の既存の認証サービスの利用。</p>

<p> もしフリーで非機密、ユーザ入力を処理しないサービスを提供するのならば認証は必要ではない。
 逆にもし、秘密情報を交換する場合、プログラムが処理するデータの入力を許可する場合、もしくはユーザのアクセスを制限する理由がある場合は、あなたは全てのユーザを認証すべきである。</p>

<p> OS X は様々なセキュアネットワークAPIや認証サービスを提供している。その全ては認証を行う。
 あなたは自身で認証メカニズムを作成するよりもこれらのサービスを常に使用するべきである。
 一例をあげると、認証は正しく実施するのが非常に難しく、誤りがあると危険です。
 もしアタッカーがあなたの認証スキームを破った場合、あなたは秘密を危険にさらすかアタッカーにシステムの侵入を許してしまうだろう。</p>

<p> ネットワークアプリケーションのための唯一の認可された認証メカニズムは Kerberos です。
 &#8220;Client-Server Authentication&#8221;を参照してください。セキュアネットワーキングについてのより詳細な情報は Secure Transport Reference と CFNetwork Programming Guide を参照してください。</p></li>
<li><p>プログラムによるアクセス検証</p>

<p> UIの制限はアタックからあなたのサービスを保護しない。
 特定のユーザのみアクセス可能にしなければならないような機能を提供しようとする場合、そのサービスは現在のユーザがその機能にアクセスすることを許可されているか適切なチェックを行う必要がある。</p>

<p> もしあなたがこれを行わない場合、あなたのサービスを十分に理解しているユーザには、URLを変更する、悪意のあるAppleイベントを送信するなど不正な操作を実行することができる。</p></li>
<li><p>優雅に失敗せよ</p>

<p> ネットワーク障害やサーバがDoS攻撃を受けているといったことが原因でサーバが利用できない場合、あなたのクライアントアプリケーションは頻度やリトライ回数を制限し、ユーザに操作をキャンセルできる機会を設けなければならない。</p>

<p> あまりにも頻繁に・しつこく再接続を行う、もしくは接続を待っているあいだハングするような貧弱な設計のクライアントは、無自覚にDoSに加担するか、自身に対するDoSを引き起こす可能性がある。</p></li>
<li><p>接続量を多く処理するためのサービス設計</p>

<p> あなたのデーモンはDoS攻撃に対してクラッシュやデータの損失無しで生き続けることができなくてはならない。
 さらに、DoS攻撃を受けたデーモンがシステム上の全てのプロセスのDoSを引き起こすことがないように、各デーモンが利用することができるプロセッサー時間やメモリやディスク容量の総量を制限剃る必要があります。</p>

<p> あなたはインターネットデーモンのパケットとトラフィックフローを制御する ipfw ファイアウォールプログラムを使用することができます。マニュアルページ ipfw(8) を参照してください。
 Wheeler ならばDoS攻撃に対処する上でより多くのアドバイスのため、 http://www.dwheeler.com/secure-programs/ で利用可能な Secure Programming for Linux and Unix HOWTO  を参照してください。</p></li>
<li><p>注意深いハッシュ関数の設計</p>

<p> ハッシュテーブルは多くの場合、検索性能を改善するために用いられています。
 ただし、ハッシュ衝突がある場合（リスト内の２つの項目が同一のハッシュ結果を持つ場合）、衝突を解決するためにより遅い（しばしば線形）探索を利用しなければなりません。
 同一のハッシュ結果をもつ異なるリクエストを意図的に生成することが可能ならば、そのようなリクエストを多量に生成することでアタッカーはDoSアタックを仕掛けることが可能となります。</p>

<p> 衝突するケースでは Tree のような複雑なデータ構造を使用するハッシュテーブルを設計することが可能です。
 そうすることでそれらのアタックによるダメージを大幅に減らすことができます。</p></li>
</ol>


<h1>監査ログ <!-- Audit Logs --></h1>

<!-- It’s very important to audit attempts to connect to a server or to gain authorization to use a secure program. If someone is attempting to attack your program, you should know what they are doing and how they are doing it. -->


<p>サーバに接続したり、セキュアなプログラムを利用するために認証を得るための試行を監査することは非常に重要です。
誰かがあなたのプログラムを攻撃しようとした場合、あなたは彼らが何をしているか、どのようにおこなっているかを知る必要があります。</p>

<!-- Furthermore, if your program is attacked successfully, your audit log is the only way you can determine what happened and how extensive the security breach was. This checklist is intended to help you make sure you have an adequate logging mechanism in place. -->


<p>さらに、あなたのプログラムが首尾よく攻撃された場合、監査ログは何が起きてどのように大規模なセキュリティ侵害があったかを判断できる唯一の方法です。
このチェックリストは適切な場所に十分なログメカニズムをもっているか確認するためのものです。</p>

<!-- Important: Don’t log confidential data, such as passwords, which could then be read later by a malicious user. -->


<p><em>重要：パスワードといった機密データをログに残してはいけない。それは悪意あるユーザによって後から読まれる可能性がある。</em></p>

<!-- Audit attempts to connect. -->


<!-- Your daemon or secure program should audit connection attempts (both successful attempts and failures). -->




<!-- Note that an attacker can attempt to use the audit log itself to create a denial of service attack; therefore, you should limit the rate of entering audit messages and the total size of the log file. You also need to validate the input to the log itself, so that an attacker can’t enter special characters such as the newline character that you might misinterpret when reading the log. -->




<!-- See Wheeler, Secure Programming for Linux and Unix HOWTO for some advice on audit logs. -->




<!-- Use the libbsm auditing library where possible. -->


<!-- The libbsm auditing library is part of the TrustedBSD project, which in turn is a set of trusted extensions to the FreeBSD operating system. Apple has contributed to this project and has incorporated the audit library into the Darwin kernel of the OS X operating system. (This library is not available in iOS.) -->




<!-- You can use the libbsm auditing library to implement auditing of your program for login and authorization attempts. This library gives you a lot of control over which events are audited and how to handle denial of service attacks. -->




<!-- The libbsm project is located at http://www.opensource.apple.com/darwinsource/Current/bsm/. For documentation of the BSM service, see the “Auditing Topics” chapter in Sun Microsystems’ System Administration Guide: Security Services located at http://docs.sun.com/app/docs/doc/806-4078/6jd6cjs67?a=view. -->




<!-- If you cannot use libbsm, be careful when writing audit trails. -->


<!-- When using audit mechanisms other than libbsm, there are a number of pitfalls you should avoid, depending on what audit mechanism you are using: -->




<!-- syslog -->




<!-- syslog -->


<!-- Prior to the implementation of the libbsm auditing library, the standard C library function syslog was most commonly used to write data to a log file. If you are using syslog, consider switching to libbsm, which gives you more options to deal with denial of service attacks. If you want to stay with syslog, be sure your auditing code is resistant to denial of service attacks, as discussed in step 1. -->




<!-- Custom log file -->


<!-- If you have implemented your own custom logging service, consider switching to libbsm to avoid inadvertently creating a security vulnerability. In addition, if you use libbsm your code will be more easily maintainable and will benefit from future enhancements to the libbsm code. -->




<!-- If you stick with your own custom logging service, you must make certain that it is resistant to denial of service attacks (see step 1) and that an attacker can’t tamper with the contents of the log file. -->




<!-- Because your log file must be either encrypted or protected with access controls to prevent tampering, you must also provide tools for reading and processing your log file. -->




<!-- Finally, be sure your custom logging code is audited for security vulnerabilities. -->


<ol>
<li><p>接続の試行を監査</p>

<p> あなたのデーモンやセキュアプログラムは接続試行（成功も失敗も両方）を監査する必要がある。</p>

<p> アタッカーはDoS攻撃を作り出すために監査ログそのものを使用することを試みることができる点について注意してください。
 つまり、監査メッセージをいれる割合やログ・ファイルのサイズについて制限する必要があることです。
 ログファイルを読むときに誤解するような改行文字といった特別な文字をアタッカーが入れることができないように、ログそのもののインプットを検証もおこなう必要がある。</p>

<p> Wheeler は監査ログについてのアドバイスのため、 Secure Programming for Linux and Unix HOWTO を参照してください。</p></li>
<li><p>libbsm 監査ログライブラリの可能な限り使用</p>

<p> libbsm 監査ライブラリは Trusted BSD プロジェクトの一部です。それはFreeBSDの信頼性のある拡張です。
 Apple はこのプロジェクトに貢献しており、OSX の Darwin カーネルに監査ライブラリが組み込まれています（このライブラリは iOS では利用できません）。</p>

<p> あなたはログインや認証への試みるプログラムの監査を実装するために libbsm 監査ライブラリを使用することができる。
 このライブラリを使用するとイベントが監査されるときやDoS攻撃をどのように扱うといった多くの制御が与えられる。</p>

<p> libbsm プロジェクトは http://www.opensource.apple.com/darwinsource/Current/bsm/ にあります。
 BSMサービスのドキュメントは http://docs.sun.com/app/docs/doc/806-4078/6jd6cjs67?a=view にあるサン・マイクロシステムズの System Administration Guide: Security Services にある &#8220;Auditing Topics&#8221; 章を参照してください。</p></li>
<li><p>もし libbsm を使用できない場合、監査証跡を書くときには注意すること</p>

<p> libbsm ではなく他の監査メカニズムを使用する場合、使用する監査メカニズムに応じて、避けるべき多くの落とし穴や頼るべきことがいくつか存在する。</p>

<ul>
<li><p>syslog</p>

<p>libbsm 監査ライブラリの実装の前に、標準Cライブラリ関数の syslog はログの書き込みに最も一般的に使用されていた。
もし syslog を使用する場合、libbsm への切り替えを検討してください。それはDoS攻撃の対応にさらなるオプションを与えます。
もし syslog にとどまりたいのならば、手順１で説明したように、監査コードがDoS攻撃に耐性があることを確認してください。</p></li>
<li><p>カスタムログファイル</p>

<p>あなたがカスタムロギングサービスを実装する場合、セキュリティ脆弱性をうっかり作ることを避けるために libbsm に切り替えることを考慮してください。
付け加えると、あなたが libbsm を使用すればあなたのコードはより簡単にメンテナンス可能となり libbsm への将来的な拡張からの恩恵を受けるだろう。</p>

<p>もしカスタムロギングサービスに固執するならば、あなたはDoS攻撃（ステップ１を参照）やアタッカーがログ・ファイルの内容を改竄できないことを確かめる必要がある。</p>

<p>ログファイルは改ざんを防ぐために暗号化またはアクセス制御されなければならないため、ログファイルを読み取って処理するツールも提供する必要がある。</p>

<p>最後に、あなたのカスタムロギングコードはセキュリティ脆弱性について監査されていることを確認してください。</p></li>
</ul>
</li>
</ol>


<h1>クライアントーサーバ認証 <!-- Client-Server Authentication --></h1>

<p>If any private or secret information is passed between a daemon and a client process, both ends of the connection should be authenticated. This checklist is intended to help you determine whether your daemon’s authentication mechanism is safe and adequate. If you are not writing a daemon, skip to “Integer and Buffer Overflows.”</p>

<p>Do not store, validate, or modify passwords yourself.
It’s a very bad idea to store, validate, or modify passwords yourself, as it’s very hard to do so securely, and OS X and iOS provide secure facilities for just that purpose.</p>

<p>In OS X, you can use the keychain to store passwords and Authorization Services to create, modify, delete, and validate user passwords (see Keychain Services Programming Guide and Authorization Services Programming Guide).
In OS X, if you have access to an OS X Server setup, you can use Open Directory (see Open Directory Programming Guide) to store passwords and authenticate users.
On an iOS device, you can use the keychain to store passwords. iOS devices authenticate the application that is attempting to obtain a keychain item rather than asking the user for a password. By storing data in the keychain, you also ensure that they remain encrypted in any device backups.
Never send passwords over a network connection in cleartext form.
You should never assume that an unencrypted network connection is secure. Information on an unencrypted network can be intercepted by any individual or organization between the client and the server.</p>

<p>Even an intranet, which does not go outside of your company, is not secure. A large percentage of cyber crime is committed by company insiders, who can be assumed to have access to a network inside a firewall.</p>

<p>OS X provides APIs for secure network connections; see Secure Transport Reference and CFNetwork Programming Guide for details.</p>

<p>Use server authentication as an anti-spoofing measure.
Although server authentication is optional in the SSL/TLS protocols, you should always do it. Otherwise, an attacker might spoof your server, injuring your users and damaging your reputation in the process.</p>

<p>Use reasonable pasword policies.
Password strength
In general, it is better to provide the user with a means to evaluate the strength of a proposed password rather than to require specific combinations of letters, numbers, or punctuation, as arbitrary rules tend to cause people to choose bad passwords to fit the standard (Firstname.123) instead of choosing good passwords.</p>

<p>Password expiration
Password expiration has pros and cons. If your service transmits passwords in cleartext form, it is absolutely essential.</p>

<p>If your password transmission is considered secure, however, password expiration can actually weaken security by causing people to choose weaker passwords that they can remember or to write their passwords down on sticky notes on their monitors.</p>

<p>See Password Expiration Considered Harmful for more information.</p>

<p>Non-password authentication
Hardware-token-based authentication provides far more security than any password scheme because the correct response changes every time you use it. These tokens should always be combined with a PIN, and you should educate your users so that they do not write their username or PIN on the token itself.</p>

<p>Disabled accounts
When an employee leaves or a user closes an account, the account should be disabled so that it cannot be compromised by an attacker. The more active accounts you have, the greater the probability that one will have a weak password.</p>

<p>Expired accounts
Expiring unused accounts reduces the number of active accounts, and in so doing, reduces the risk of an old account getting compromised by someone stealing a password that the user has used for some other service.</p>

<p>Note, however, that expiring a user account without warning the user first is generally a bad idea. If you do not have a means of contacting the user, expiring accounts are generally considered poor form.</p>

<p>Changing passwords
You can require that the client application support the ability to change passwords, or you can require that the user change the password using a web interface on the server itself.</p>

<p>In either case, the user (or the client, on behalf of the user) must provide the previous password along with the new password (twice unless the client is updating it programmatically over a sufficiently robust channel).</p>

<p>Lost password retrieval (such as a system that triggers the user’s memory or a series of questions designed to authenticate the user without a password)
Make sure your authentication method is not so insecure that an attacker doesn’t even bother to try a password, and be careful not to leak information, such as the correct length of the password, the email address to which the recovered password is sent, or whether the user ID is valid.</p>

<p>You should always allow (and perhaps even require) customer to choose their own security questions. Pre-written questions are inherently dangerous because any question that is general enough for you to ask it of a large number of people is:</p>

<p>likely to be a request for information that a large number of that person’s friends already know. In all likelihood, everyone who attended your high school can guess (in a handful of guesses) who your kindergarten teacher was, who your high school mascot was, and so on.
probably on your public profile on a social networking site. For example, if you ask where you were born, chances are that’s public information. Even if it isn’t on your profile, someone can dig it up through government records.
potentially guessable given other information about the person. For example, given the last four digits of a social security number, someone’s birthdate, and the city in which that person was born, you can fairly easily guess then entire social security number.
Finally, you should always allow your users the option of not filing out security questions. The mere existence of security questions makes their accounts less secure, so security-conscious individuals should be allowed to refuse those questions entirely.
Limitations on password length (adjustable by the system administrator)
In general, you should require passwords to be at least eight characters in length. (As a side note, if your server limits passwords to a maximum of eight characters, you need to rethink your design. There should be no maximum password length at all, if possible.)</p>

<p>The more of these policies you enforce, the more secure your server will be. Rather than creating your own password database—which is difficult to do securely—you should use the Apple Password Server. See Open Directory Programming Guide for more information about the Password Server, Directory Service Framework Reference for a list of Directory Services functions, and the manual pages for pwpolicy(8), passwd(1), passwd(5), and getpwent(3) at http://developer.apple.com/documentation/Darwin/Reference/ManPages/index.html for tools to access the password database and set password policies.
Do not store unencrypted passwords and do not reissue passwords.
In order to reissue a password, you first have to cache the unencrypted password, which is bad security practice. Furthermore, when you reissue a password, you might also be reusing that password in an inappropriate security context.</p>

<p>For example, suppose your program is running on a web server, and you use SSL to communicate with clients. If you take a client’s password and use it to log into a database server to do something on the client’s behalf, there’s no way to guarantee that the database server keeps the password secure and does not pass it on to another server in cleartext form. Therefore, even though the password was in a secure context when it was being sent to the web server over SSL, when the web server reissues it, it’s in an insecure context.</p>

<p>If you want to spare your client the trouble of logging in separately to each server, you should use some kind of forwardable authentication, such as Kerberos. For more information on Apple’s implementation of Kerberos, see http://developer.apple.com/darwin/projects/kerberos/.</p>

<p>Under no circumstances should you design a system in which system administrators or other employees can see users’ passwords. Your users are trusting you with passwords that they may use for other sites; therefore, it is extremely reckless to allow anyone else to see those passwords. Administrators should be allowed to reset passwords to new values, but should never be allowed to see the passwords that are already there.</p>

<p>Support Kerberos.
Kerberos is the only authorization service available over a network for OS X servers, and it offers single-sign-on capabilities. If you are writing a server to run on OS X, you should support Kerberos. When you do:</p>

<p>Be sure you’re using the latest version (v5).
Use a service-specific principal, not a host principal. Each service that uses Kerberos should have its own principal so that compromise of one key does not compromise more than one service. If you use a host principal, anyone who has your host key can spoof login by anybody on the system.
The only alternative to Kerberos is combining SSL/TLS authentication with some other means of authorization such as an access control list.
Restrict guest access appropriately.
If you allow guest access, be sure that guests are restricted in what they can do, and that your user interface makes clear to the system administrator what guests can do. Guest access should be off by default. It’s best if the administrator can disable guest access.</p>

<p>Also, as noted previously, be sure to limit what guests can do in the code that actually performs the operation, not just in the code that generates the user interface. Otherwise, someone with sufficient knowledge of the system can potentially perform those unauthorized operations in other ways (by modifying URLs, for example).</p>

<p>Do not implement your own directory service.
Open Directory is the directory server provided by OS X for secure storage of passwords and user authentication. It is important that you use this service and not try to implement your own, as secure directory servers are difficult to implement and an entire directory’s passwords can be compromised if it’s done wrong. See Open Directory Programming Guide for more information.</p>

<p>Scrub (zero) user passwords from memory after validation.
Passwords must be kept in memory for the minimum amount of time possible and should be written over, not just released, when no longer needed. It is possible to read data out of memory even if the application no longer has pointers to it.</p>

<h1>整数／バッファオーバーフロー <!-- Integer and Buffer Overflows --></h1>

<!-- As discussed in “Avoiding Buffer Overflows And Underflows,” buffer overflows are a major source of security vulnerabilities. This checklist is intended to help you identify and correct buffer overflows in your program. -->




<!-- Use unsigned values when calculating memory object offsets and sizes. -->


<!-- Signed values make it easier for an attacker to cause a buffer overflow, creating a security vulnerability, especially if your application accepts signed values from user input or other outside sources. -->




<!-- Be aware that data structures referenced in parameters might contain signed values. -->




<!-- See “Avoiding Integer Overflows And Underflows” and “Calculating Buffer Sizes” for details. -->




<!-- Check for integer overflows (or signed integer underflows) when calculating memory object offsets and sizes. -->


<!-- You must always check for integer overflows or underflows when calculating memory offsets or sizes. Integer overflows and underflows can corrupt memory in ways that can lead to execution of arbitrary code. -->




<!-- See “Avoiding Integer Overflows And Underflows” and “Calculating Buffer Sizes” for details. -->




<!-- Avoid unsafe string-handling functions. -->


<!-- The functions strcat, strcpy, strncat, strncpy, sprintf, vsprintf, gets have no built-in checks for string length, and can lead to buffer overflows. -->




<!-- For alternatives, read “String Handling.” -->


<p>&#8220;Avoiding Buffer Overflows And Underflows&#8221; で説明しているように、バッファオーバーフローはセキュリティ脆弱性の主な原因です。
このチェックリストはあなたのプログラムのバッファオーバーフローを確認・修正する一助になることを意図しています。</p>

<ol>
<li><p>メモリオブジェクトのオフセットやサイズを計算するときは符号なしの値を使用すること</p>

<p> 符号付きの値はアタッカーにとって、特にユーザ入力や外部ソースから符号付きの値を受け入れる場合に、バッファオーバーフローやセキュリティ脆弱性を引き起こすのが容易である。</p>

<p> パラメータで参照するデータ構造に符号付きの値が含まれているか気をつけてください。</p>

<p> 詳細は &#8220;Avoiding Integer Overflows And Underflows&#8221; と &#8220;Calculating Buffer Sizes&#8221; を参照してください。</p></li>
<li><p>メモリオブジェクトのオフセットやサイズを計算するときは整数オーバーフロー（もしくは符号付き整数アンダーフロー）のチェックをすること</p>

<p> メモリオフセットやサイズを計算するときは常に整数オーバーフローかアンダーフローを常にチェックする必要がある。
 整数オーバーフローやアンダーフローはメモリ破壊をし、任意のコードを実行を可能とする。</p>

<p> 詳細は &#8220;Avoiding Integer Overflows And Underflows&#8221; と &#8220;Calculating Buffer Sizes&#8221; を参照してくだい。</p></li>
<li><p>危険な文字列操作関数を避けること</p>

<p> <em>strcat</em>, <em>strcpy</em>, <em>strncat</em>, <em>strncpy</em>, <em>sprintf</em>, <em>vsprintf</em>, <em>gets</em> 関数は文字長のチェックがビルトインで持たず、バッファオーバーフローの原因となる。</p>

<p> 代替手段は &#8220;String Handling.&#8221; を読んでください。</p></li>
</ol>


<h1>暗号関数の使用 <!-- Cryptographic Function Use --></h1>

<p>This checklist is intended to help you determine whether your program has any vulnerabilities related to use of encryption, cryptographic algorithms, or random number generation.</p>

<p>Use trusted random number generators.
Do not attempt to generate your own random numbers.</p>

<p>There are several ways to obtain high-quality random numbers:</p>

<p>In iOS, use the Randomization Services programming interface.
In OS X:
Read from /dev/random in OS X (see the manual page for random).
Use the read_random function in the header file random.h in the Apple CSP module, which is part of Apple’s implementation of the CDSA framework (available at http://developer.apple.com/darwin/projects/security/).
Note that rand does not return good random numbers and should not be used.
Use TLS/SSL instead of custom schemes.
You should always use accepted standard protocols for secure networking. These standards have gone through peer review and so are more likely to be secure.</p>

<p>In addition, you should always use the most recent version of these protocols.</p>

<p>To learn more about the secure networking protocols available in OS X and iOS, read “Secure Network Communication APIs” in Cryptographic Services Guide.</p>

<p>Don’t roll your own crypto algorithms.
Always use existing optimized functions. It is very difficult to implement a secure cryptographic algorithm, and good, secure cryptographic functions are readily available.</p>

<p>To learn about the cryptographic services available in OS X and iOS, read Cryptographic Services Guide.</p>

<h1>インストールとローディング <!-- Installation and Loading --></h1>

<p>Many security vulnerabilities are caused by problems with how programs are installed or code modules are loaded. This checklist is intended to help you find any such problems in your project.</p>

<p>Don’t install components in /Library/StartupItemsor/System/Library/Extensions.
Code installed into these directories runs with root permissions. Therefore, it is very important that such programs be carefully audited for security vulnerabilities (as discussed in this checklist) and that they have their permissions set correctly.</p>

<p>For information on proper permissions for startup items, see “Startup Items”. (Note that in OS X v10.4 and later, startup items are deprecated; you should use launchd to launch your daemons instead. See Daemons and Services Programming Guide for more information.)</p>

<p>For information on permissions for kernel extensions, see Kernel Extension Programming Topics. (Note that beginning in OS X v10.2, OS X checks for permissions problems and refuses to load extensions unless the permissions are correct.)</p>

<p>Don’t use custom install scripts.
Custom install scripts add unnecessary complexity and risk, so when possible, you should avoid them entirely.</p>

<p>If you must use a custom install script, you should:</p>

<p>If your installer script runs in a shell, read and follow the advice in “Shell Script Security” in Shell Scripting Primer.
Be sure that your script follows the guidelines in this checklist just as the rest of your application does.
In particular:</p>

<p>Don’t write temporary files to globally writable directories.
Don’t execute with higher privileges than necessary.
In general, your script should execute with the same privileges the user has normally, and should do its work in the user’s directory on behalf of the user.</p>

<p>Don’t execute with elevated privileges any longer than necessary.
Set reasonable permissions on your installed app.
For example, don’t give everyone read/write permission to files in the app bundle if only the owner needs such permission.</p>

<p>Set your installer’s file code creation mask (umask) to restrict access to the files it creates (see “Securing File Operations”).
Check return codes, and if anything is wrong, log the problem and report the problem to the user through the user interface.
For advice on writing installation code that needs to perform privileged operations, see Authorization Services Programming Guide. For more information about writing shell scripts, read Shell Scripting Primer.
Load plug-ins and libraries only from secure locations.
An application should load plug-ins only from secure directories. If your application loads plug-ins from directories that are not restricted, then an attacker might be able to trick the user into downloading malicious code, which your application might then load and execute.</p>

<p>Important: In code running with elevated privileges, directories writable by the user are not considered secure locations.
Be aware that the dynamic link editor (dyld) might link in plugins, depending on the environment in which your code is running. If your code uses loadable bundles (CFBundle or NSBundle), then it is dynamically loading code and could potentially load bundles written by a malicious hacker.
See Code Loading Programming Topics for more information about dynamically loaded code.</p>

<h1>外部ツールとライブラリの使用 <!-- Use of External Tools and Libraries --></h1>

<p>If your program includes or uses any command-line tools, you have to look for security vulnerabilities specific to the use of such tools. This checklist is intended to help you find and correct such vulnerabilities.</p>

<p>Execute tools safely.
If you are using routines such as popen or system to send commands to the shell, and you are using input from the user or received over a network to construct the command, you should be aware that these routines do not validate their input. Consequently, a malicious user can pass shell metacharacters—such as an escape sequence or other special characters—in command line arguments. These metacharacters might cause the following text to be interpreted as a new command and executed.</p>

<p>In addition, when calling functions such as execlp, execvp, popen, or system that use the PATH environment variable to search for executables, you should always specify a complete absolute path to any tool that you want to run. If you do not, a malicious attacker can potentially cause you to run a different tool using an environment variable attack. When possible, use execvP (which takes an explicit search path argument) or avoid these functions altogether.</p>

<p>See Viega and McGraw, Building Secure Software, Addison Wesley, 2002, and Wheeler, Secure Programming for Linux and Unix HOWTO, available at http://www.dwheeler.com/secure-programs/, for more information on problems with these and similar routines and for secure ways to execute shell commands.</p>

<p>Do not pass sensitive information on the command line.
If your application executes command-line tools, keep in mind that your process environment is visible to other users (see man ps(1)). You must be careful not to pass sensitive information in an insecure manner. Instead, pass sensitive information to your tool through some other means such as:</p>

<p>Pipe or standard input
A password is safe while being passed through a pipe; however, you must be careful that the process sending the password obtains and stores it in a safe manner.</p>

<p>Environment variables
Environment variables can potentially be read by other processes and thus may not be secure. If you use environment variables, you must be careful to avoid passing them to any processes that your command-line tool or script might spawn.</p>

<p>See “Shell Script Security” in Shell Scripting Primer for details.</p>

<p>Shared memory
Named and globally-shared memory segments can be read by other processes. See “Interprocess Communication And Networking” for more information about secure use of shared memory.</p>

<p>Temporary file
Temporary files are safe only if kept in a directory to which only your program has access. See “Data, Configuration, and Temporary Files,” earlier in this chapter, for more information on temporary files.</p>

<p>Validate all arguments (including the name).
Also, remember that anyone can execute a tool—it is not executable exclusively through your program. Because all command-line arguments, including the program name (argv(0)), are under the control of the user, your tool should validate every parameter (including the name, if the tool’s behavior depends on it).</p>

<h1>カーネルセキュリティ <!-- Kernel Security --></h1>

<p>This checklist is intended to help you program safely in the kernel.</p>

<p>Note: Coding in the kernel poses special security risks and is seldom necessary. See Coding in the Kernel for alternatives to writing kernel-level code.
Verify the authenticity of Mach-based services.
Kernel-level code can work directly with the Mach component. A Mach port is an endpoint of a communication channel between a client who requests a service and a server that provides the service. Mach ports are unidirectional; a reply to a service request must use a second port.</p>

<p>If you are using Mach ports for communication between processes, you should check to make sure you are contacting the correct process. Because Mach bootstrap ports can be inherited, it is important for servers and clients to authenticate each other. You can use audit trailers for this purpose.</p>

<p>You should create an audit record for each security-related check your program performs. See “Audit Logs,” earlier in this chapter, for more information on audit records.</p>

<p>Verify the authenticity of other user-space services.
If your kernel extension was designed to communicate with only a specific user-space daemon, you should check not only the name of the process, but also the owner and group to ensure that you are communicating with the correct process.</p>

<p>Handle buffers correctly.
When copying data to and from user space, you must:</p>

<p>Check the bounds of the data using unsigned arithmetic—just as you check all bounds (see “Integer and Buffer Overflows,” earlier in this chapter)—to avoid buffer overflows.
Check for and handle misaligned buffers.
Zero all pad data when copying to or from user-space memory.
If you or the compiler adds padding to align a data structure in some way, you should zero the padding to make sure you are not adding spurious (or even malicious) data to the user-space buffer, and to make sure that you are not accidentally leaking sensitive information that may have been in that page of memory previously.</p>

<p>Limit the memory resources a user may request.
If your code does not limit the memory resources a user may request, then a malicious user can mount a denial of service attack by requesting more memory than is available in the system.</p>

<p>Sanitize any kernel log messages.
Kernel code often generates messages to the console for debugging purposes. If your code does this, be careful not to include any sensitive information in the messages.</p>

<p>Don’t log too much.
The kernel logging service has a limited buffer size to thwart denial of service attacks against the kernel. This means that if your kernel code logs too frequently or too much, data can be dropped.</p>

<p>If you need to log large quantities of data for debugging purposes, you should use a different mechanism, and you must disable that mechanism before deploying your kernel extension. If you do not, then your extension could become a denial-of-service attack vector.</p>

<p>Design hash functions carefully.
Hash tables are often used to improve search performance. However, when there are hash collisions (where two items in the list have the same hash result), a slower (often linear) search must be used to resolve the conflict. If it is possible for a user to deliberately generate different requests that have the same hash result, by making many such requests an attacker can mount a denial of service attack.</p>

<p>It is possible to design hash tables that use complex data structures such as trees in the collision case. Doing so can significantly reduce the damage caused by these attacks.</p>

</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<script>
  jQuery.noConflict()('li.other').hover (
    function () {
    jQuery.noConflict()(this).toggleClass("current-menu-item")
  });
</script>

      </div>
    </div>
  
  <footer role="contentinfo"  class="sixteen columns"><center>
<p class="credit">
  <span class="credit">Powered by <a href="http://github.com">GitHub</a>, <a href="https://github.com/imathis/octopress">Octopress</a>, &amp; <a href="https://github.com/dhgamache/Skeleton">Skeleton</a></span>.
</p>
</center>
</footer>
  
  

<script type="text/javascript">
      var disqus_shortname = 'shin-github-blog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://fruitymidnight.github.io/apple-secure-coding-guideline/index.html';
        var disqus_url = 'http://fruitymidnight.github.io/apple-secure-coding-guideline/index.html';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>






<script>
  $('li.other').hover (
    function () {
    $(this).toggleClass("current-menu-item")
  });
</script>

</body>
</html>


  </div> <!-- container -->
